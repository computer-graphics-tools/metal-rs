//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use objc2::rc::{Allocated, Retained};
use objc2::runtime::ProtocolObject;
use objc2::{extern_class, extern_conformance, extern_methods, extern_protocol};
use objc2_foundation::{
    CopyingHelper, NSArray, NSCopying, NSInteger, NSObject, NSObjectProtocol, NSRange, NSString,
    NSUInteger,
};

use crate::*;

extern_class!(
    /// Description for a machine learning pipeline state.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metal/mtl4machinelearningpipelinedescriptor?language=objc)
    #[unsafe(super(MTL4PipelineDescriptor, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MTL4MachineLearningPipelineDescriptor;
);

extern_conformance!(
    unsafe impl NSCopying for MTL4MachineLearningPipelineDescriptor {}
);

unsafe impl CopyingHelper for MTL4MachineLearningPipelineDescriptor {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MTL4MachineLearningPipelineDescriptor {}
);

impl MTL4MachineLearningPipelineDescriptor {
    extern_methods!(
        /// Assigns an optional string that helps identify pipeline states you create from this descriptor.
        #[unsafe(method(label))]
        #[unsafe(method_family = none)]
        pub unsafe fn label(&self) -> Option<Retained<NSString>>;

        /// Setter for [`label`][Self::label].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLabel:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLabel(&self, label: Option<&NSString>);

        /// Assigns the function that the machine learning pipeline you create from this descriptor executes.
        #[unsafe(method(machineLearningFunctionDescriptor))]
        #[unsafe(method_family = none)]
        pub unsafe fn machineLearningFunctionDescriptor(
            &self,
        ) -> Option<Retained<MTL4FunctionDescriptor>>;

        /// Setter for [`machineLearningFunctionDescriptor`][Self::machineLearningFunctionDescriptor].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMachineLearningFunctionDescriptor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMachineLearningFunctionDescriptor(
            &self,
            machine_learning_function_descriptor: Option<&MTL4FunctionDescriptor>,
        );

        /// Sets the dimension of an input tensor at a buffer index.
        ///
        /// - Parameters:
        /// - dimensions: the dimensions of the tensor.
        /// - bufferIndex: Index of the tensor to modify.
        #[unsafe(method(setInputDimensions:atBufferIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInputDimensions_atBufferIndex(
            &self,
            dimensions: Option<&MTLTensorExtents>,
            buffer_index: NSInteger,
        );

        /// Sets the dimensions of multiple input tensors on a range of buffer bindings.
        ///
        /// Use this method to specify the dimensions of multiple input tensors at a range of indices in a single call.
        ///
        /// You can indicate that any tensors in the range have unspecified dimensions by providing `NSNull` at the their
        /// corresponding index location in the array.
        ///
        /// - Important: The range's length property needs to match the number of dimensions you provide. Specifically,
        /// `range.length` needs to match `dimensions.count`.
        ///
        /// - Parameters:
        /// - dimensions: An array of tensor extents.
        /// - range: The range of inputs of the `dimensions` argument.
        /// The range's `length` needs to match the dimensions' `count` property.
        #[unsafe(method(setInputDimensions:withRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInputDimensions_withRange(
            &self,
            dimensions: &NSArray<MTLTensorExtents>,
            range: NSRange,
        );

        /// Obtains the dimensions of the input tensor at `bufferIndex` if set, `nil` otherwise.
        #[unsafe(method(inputDimensionsAtBufferIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn inputDimensionsAtBufferIndex(
            &self,
            buffer_index: NSInteger,
        ) -> Option<Retained<MTLTensorExtents>>;

        /// Resets the descriptor to its default values.
        #[unsafe(method(reset))]
        #[unsafe(method_family = none)]
        pub unsafe fn reset(&self);
    );
}

/// Methods declared on superclass `NSObject`.
impl MTL4MachineLearningPipelineDescriptor {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Represents reflection information for a machine learning pipeline state.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metal/mtl4machinelearningpipelinereflection?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MTL4MachineLearningPipelineReflection;
);

unsafe impl Send for MTL4MachineLearningPipelineReflection {}

unsafe impl Sync for MTL4MachineLearningPipelineReflection {}

extern_conformance!(
    unsafe impl NSObjectProtocol for MTL4MachineLearningPipelineReflection {}
);

impl MTL4MachineLearningPipelineReflection {
    extern_methods!(
        /// Describes every input and output of the pipeline.
        #[unsafe(method(bindings))]
        #[unsafe(method_family = none)]
        pub unsafe fn bindings(&self) -> Retained<NSArray<ProtocolObject<dyn NSObjectProtocol>>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MTL4MachineLearningPipelineReflection {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// A pipeline state that you can use with machine-learning encoder instances.
    ///
    /// See ``MTL4MachineLearningCommandEncoder`` for more information.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metal/mtl4machinelearningpipelinestate?language=objc)
    pub unsafe trait MTL4MachineLearningPipelineState:
        MTLAllocation + NSObjectProtocol + Send + Sync
    {
        /// Queries the string that helps identify this object.
        #[unsafe(method(label))]
        #[unsafe(method_family = none)]
        unsafe fn label(&self) -> Option<Retained<NSString>>;

        /// Returns the device the pipeline state belongs to.
        #[unsafe(method(device))]
        #[unsafe(method_family = none)]
        unsafe fn device(&self) -> Retained<ProtocolObject<dyn MTLDevice>>;

        /// Returns reflection information for this machine learning pipeline state.
        #[unsafe(method(reflection))]
        #[unsafe(method_family = none)]
        unsafe fn reflection(&self) -> Option<Retained<MTL4MachineLearningPipelineReflection>>;

        /// Obtain the size of the heap, in bytes, this pipeline requires during the execution.
        ///
        /// Use this value to allocate a ``MTLHeap`` instance of sufficient size that you can then provide to
        /// ``MTL4MachineLearningCommandEncoder/dispatchNetworkWithIntermediatesHeap:``.
        ///
        /// Metal uses this heap to store intermediate data as it executes the pipeline. It is your responsibility to provide
        /// a heap at least as large as this property requests.
        #[unsafe(method(intermediatesHeapSize))]
        #[unsafe(method_family = none)]
        unsafe fn intermediatesHeapSize(&self) -> NSUInteger;
    }
);
